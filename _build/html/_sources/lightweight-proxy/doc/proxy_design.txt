# Light Weight Proxy (LWP) Design
LWP is designed to collect and report various statistics, and load balance
client requests or connections across a pool of applications deployed in a
distibuted data center environment. The initial release will support:
* deployment in a MESOS / Marathon framework
* HTTP and TCP proxying functionality

LWP is built on a modular, pluggable architecture much like common node.js middleware
frameworks. On a high-level, it consists of the following components.

## LWP Proxy
The LWP-proxy acts as the middleware framework and provides logic for
adding pluggable modules (also referred to as the middleware), and invoking the
callbacks provided by the modules in the order they were added.

## LWP Pluggable Modules
All middleware modules export a method which takes an optional configuration object
and return an object with the methods that get attached into the proxy datapath
by the LWP Proxy middleware framework.

### API
The middleware API described below is inspired by Express framework.

#### function interceptHttpReq(proxyReq, cliRes, reqNextCb)
Invoked when an HTTP request is received by the proxy from the client (only
applicable when service-type is HTTP).  
**Arguments:**
* `proxyReq` - LwpHttpIncoming object:  
    - Created from the client request, this object can be manipulated by each
    middleware layer and gets passed on to the next layer by the middleware
    framework.
    - The final middleware module in the request path uses this to construct the
    HTTP request that gets sent out to the backend server.
    - A middleware module can choose to manipulate headers, method, url, etc.
    using this object. 
    - A middleware module can choose to stack additional readable streams on to
    this object (data is read from the stack of streams in bottom to top order).
* `cliRes` - HTTP.ServerResponse object:  
  A middleware module can choose to write a response back to the client using this
  object.
* `reqNextCb` - callback function:  
  The current middleware module calls this function when it is done processing
  the request. Invoking the callback triggers different termination behavior
  depending on the arguments passed into the callback.  
  Signature: `function(err, proxyReq, proxyResCb)`  
  **Arguments:**
    - no arguments: In this case, we advance to the next middleware module in
    the request path.
    - `err` - Error object:  
    If not null, this causes the middleware stack to terminate in both
    directions and an error response to be sent back to the client.
    - `proxyReq` - LwpHttpIncoming or Http.ClientRequest object:
        + If a LwpHttpIncoming object is passed in, it gets passed on as the
        proxyReq object to the next module in the request path middleware stack.
        The framework then advances to the next middleware module in the request path.
        + If an Http.ClientRequest object is passed in, the request path
        middleware stack is terminated. In this case, the current middleware
        is also expected to send the Http.ClientRequest request to the backend
        server (typically used by forwarding middleware). The framework uses
        this object to hook the response path middleware stack for this request.
        + If null, the middleware stack is terminated in both directions.
        In this case, the middleware is also expected to send a response
        back to the client using cliRes (typically used when proxy wants
        to write the response back to client and terminate the transaction).
    - `proxyResCb` - callback function:  
    This function gets inserted into the middleware stack in the response path.
    **Note:** Callbacks in the middleware stack for the response path are
    invoked in the reverse order they are added.  
    Signature: `function(proxyRes, resNextCb)`  
    **Arguments:**
        + `proxyRes` - LwpHttpIncoming object:
            * Created from the server response, this object can be manipulated
            by each middleware layer in the response path and gets passed on to
            the next layer by the middleware framework.
            * The final middleware module in the response path uses this to
            write out the response that gets sent out to the client.
            * A middleware module can choose to manipulate headers, method, url, etc.
            using this object. 
            * A middleware module can choose to stack additional readable streams on to
            this object (data is read from the stack of streams in bottom to top order).
        + `resNextCb` - callback function:  
        The current middleware module calls this function when it is done
        processing the response. Invoking this callback triggers different
        termination behavior depending on the arguments passed into the
        callback.  
        Signature: `function(err, proxyRes)`  
        **Arguments:**
            * no arguments: In this case, we advance to the next module in the
            response path middleware stack.
            * `err` - Error object: If not null, this causes the middleware
            stack to terminate in both directions and an error response to be
            sent back to the client.
            * `proxyRes` - LwpHttpIncoming object:  
                - If a LwpHttpIncoming object is passed in, it gets passed on as
                  the proxyRes object to the next module in the response path
                  middleware stack.
                - If null, the middleware stack is terminated in both directions.
                In this case, the middleware is also expected to send a response
                back to the client using cliRes.

**Example usage for `reqNextCb`:**  
* Terminate middleware in both directions and send error response:  

```javascript
  reqNextCb(new Error('error while processing request'));
```
* Manipulate headers and pass it on to the next middleware module:  

```javascript
  proxyReq.headers['X-forwarded-for'] = proxyReq.socket.remoteAddress;
  reqNextCb(null, proxyReq);
```
* Transform request body and pass it on to the next middleware module:  

```javascript
  proxyReq.pushStream(proxyReq.pipe(zlib.createGunzip()));
  reqNextCb(null, proxyReq);
```
* Terminate middleware in both directions and send response:  

```javascript
  cliRes.end('response from proxy');
  reqNextCb(null, null);
```
* Create and write to new Http.ClientRequest out to backend server:  

```javascript
  // create http.ClientRequest from proxyReq 
  var newHttpReq = new http.request(proxyReq.options);
  newHttpReq.headers = proxyReq.headers; 
  proxyReq.pipe(newHttpReq);
  reqNextCb(null, newHttpReq);
```
* Register a response callback:  

```javascript
  var proxyResCb = function(proxyRes, resNextCb) {
    proxyRes.pushStream(proxyRes.pipe(zlib.createGzip()));
    resNextCb();
  };
  reqNextCb(null, proxyReq, proxyResCb)
```

#### function interceptTcpConnection(cliSock, cliNextCb)
Invoked when the proxy accepts a new TCP connection from the client (only
applicable when service-type is TCP).
**Arguments:**
* `cliSock` - LwpTcpSocket object:
    - Created from the client connection net.Socket object, this object can
    be manipulated by each middleware layer and gets passed on to the next
    layer by the middleware framework.
    - A middleware module can choose to stack additional readable streams on to
    this object (data is read from the stack of streams in bottom to top order).
* `cliNextCb`: Callback function:
  The current middleware module calls this function when it is done processing
  the client-to-server path. Invoking this callback can trigger different
  termination behavior depending on the arguments passed into the callback.  
  Signature: `function(err, cliSock, srvToCliCb)`  
  **Arguments:**
    - no arguments: In this case, we advance to the next middleware module in the
    client-to-server path.
    - `err`: Error object:  
    If not null, this causes the middleware stack to terminate in both directions
    and the client connection to be closed.
    - `cliSock`: LwpTcpSocket or Net.Socket object:
        + If a LwpTcpSocket object is passed in, it gets passed on as the
        cliSock object to the next module in the client-to-server path
        middleware stack. The framework then advances to the next middleware
        module in the client-to-server path.
        + If a Net.Socket object is passed in, the client-to-server path
        middleware stack is terminated. In this case, the current middleware is also
        expected to connect to the backend server and forward data to it
        (typically used by forwarding middleware). The framework uses
        this object to hook the server-to-client path middleware stack for
        this client connection.
        + If null, the client-to-server path middleware stack is terminated.  
    - `srvToCliCb` - callback function:  
    This function gets inserted into the middleware stack in the
    server-to-client path. **Note:** Callbacks in the middleware stack for the
    server-to-client path are invoked in the reverse order they are added.  
    Signature: `function(srvSock, srvNextCb)`  
    **Arguments:**
        + `srvSock`: LwpTcpSocket object:
            * Created from the server connection net.Socket object, this object can
            be manipulated by each middleware layer and gets passed on to the next
            layer by the middleware framework server-to-client path.
            * A middleware module can choose to stack additional readable streams on to
            this object (data is read from the stack of streams in bottom to top order).
        + `srvNextCb` - callback function:  
        The current middleware module calls this function when it is done
        processing the server-to-client path. Invoking this callback triggers
        different termination behavior depending on the arguments passed into
        the callback.  
        Signature: `function(err, srvSock)`  
        **Arguments:**
            * no arguments: In this case, we advance to the next module in the
            server-to-client path middleware stack.
            * `err` - Error object: If not null, this causes the middleware
            stack to terminate in both directions and both client and server
            connections to be terminated.
            * `srvSock`: LwpTcpSocket object:
                - If a LwpTcpSocket object is passed in, it gets passed on as the
                srvSock object to the next module in the server-to-client path
                middleware stack.
                - If null, the server-to-client path middleware stack is terminated.

**Example usage for `cliNextCb`:**  
* Terminate middleware in both directions and close client connection:

```javascript
  cliNextCb(new Error('error while processing client connection'));
```
* Transform data on client connection and pass it on to next middleware module:

```javascript
  cliSock.pushStream(cliSock.pipe(zlib.createGunzip()));
  cliNextCb();
```
* Terminate middleware in both directions and gracefuly close client connection:

```javascript
  cliSock.end('goodbye\n');
  cliNextCb(null, null);
```
* Create and write to net.Socket connection out to backend server:

```javascript
  var srvSock = new net.connect(
    {host: cliSock.targetHost, port: cliSock.targetPort});
  cliSock.pipe(srvSock);
  cliNextCb(null, srvSock);
```
* Register a callback in server-to-client path:

```javascript
  var srvToCliCb = function(srvSock, srvNextCb) {
    srvSock.pushStream(srvSock.pipe(zlib.createGzip()));
    srvNextCb();
  };
  cliNextCb(null, cliSock, srvToCliCb)
```

### Sample Code
[middlewareAPIUseCases](https://bldr-git.int.lineratesystems.com/velcro/lightweight-proxy/blob/master/doc/middlewareAPIUseCases.md)

## Configuration

### Startup / Static Configuration
This module is responsible for the startup initial configuration. This first
release will only support static configuration at startup. Configuration changes
must be made through LWP process restarts.

The main configurable component is the virtual server. The LWP will support
multiple virtual server configurations; a single LWP can support and load
balance multiple services using virtual server configurations.

Supporting multiple virtual server configurations can offer a clear road map
towards dynamic reconfiguration. New virtual server configurations can
gracefully replace old configurations; on reconfiguration the old listening
socket is closed and the underlying node-http-proxy will gracefully shutdown
once its connections are drained. All new connections are received on the new
listening socket.

Startup configurations can be added via two methods. Provide a configuration
file to read from, or set the configuration as a string to an environment
parameter. By default the LWP will attempt to read from "LWP_CONFIG".

Additional configuration variables will be passed through by the controller
which are configured in the marathon app. Environment parameters prefixed with
LWP_ENV_ will be passed through unchanged.

Configuration is now located in:
[README.md](https://bldr-git.int.lineratesystems.com/velcro/lightweight-proxy/blob/master/README.md)

### Dynamic Backend Configuration
Backend configuration will be accomplished through MesosDNS. The LWP must be
deployed in an environment configured with MesosDNS support. The LWP will prefer
to use the built-in, native service discovery supported in Mesos cluster
environments.

Requests for load balancing decisions will cause a DNS SRV record query based on
the configured virtual server "service-name". MesosDNS constructs SRV records in
this form:
```
{task}.{protocol}.framework.domain
```
In the target Marathon/Mesos environment an "service-name" of "web-service" can
be queried at this URI (Note: Marathon uses the term tasks for our concept of
"service-name"; these values are prepended with an underscore for SRV queries):
```
_web-service.tcp.marathon.mesos
```

Middlewares interested in the current state of an applications deployment can
query the MesosDNS service via the provided API:
```javascript
function getBackendServers(serviceName: string): array<string>
```

Middleware components are discouraged from caching MesosDNS results as the
cluster may change an application's deployment between requests. Since the
application topology may change requests should be made at the time the backend
list is required. The MesosDNS module (to prevent overload of the DNS system) will periodically query for the state of the application topology. This state will be returned when queried via the module API.

## Statistics
* LWP provides a library that allows stats to be generated in a format that is compatible with Splunk and BigIQ (or do we call it LEO?).
* LWP will create an instance of LWP-stats-client and pass it on into the lwp-proxy
module. Pluggable modules will have access to the stats-client via the lwp-proxy module.
* The F5Stats library usage is documented at [StatsAPI](https://bldr-git.int.lineratesystems.com/velcro/lightweight-proxy/blob/master/lib/f5stats/doc/API.md)
* Currently generated stats:
[README.md](https://bldr-git.int.lineratesystems.com/velcro/lightweight-proxy/blob/master/README.md)

## Logging
* Use the winston logger npm which allows for multiple logging levels and multiple
transports configured at different levels (for example, storing error logs in a
persistent remote location and all logs output to the console or a local file).
* At a minimum, log all errors. Work with stats team to figure out what else needs
to be logged and how frequently.
* Export logs to stdout and let orchestration framework manage it.

## Support for External load balancers (stats reporting only)
In this mode, LWP is used mainly to collect statistics and forward all requests
and connections to an external load balancer. LWP's pluggable architecture allows
us multiple options to implement this:
* Option 1: Use the normal load balancing model and configure external LB as
the only real-server.
* Option 2: Omit the load balancing module and leave all other modules in.

## Health Monitoring
LWP will not support active health monitoring initially. Instead, we rely on
the orchestration system to remove unhealthy servers from the server pool.

## Graceful restart
The initial implementation of LWP will not implement graceful restart.
Future versions will add support for graceful restart (having the notion of multiple
instances of LWP proxy will help us achieve this).

## Sample API
```javascript
    // create a lwp-proxy
    var lwp_proxy = require('lwp-proxy');
    var options = {
      type: "http", // or tcp
      ...
    };
    var proxy = lwp_proxy.createProxy(options);

    // add load-balancing module
    var lb_options = {
      algorithm: "round-robin",
      ...
    };
    var lb = require('load-balancer');
    proxy.use(lb(lb_options));

    // add forwarder module
    var forwarder_options = {
      ...
    };
    var forwarder = require('forwarder');
    proxy.use(forwarder(forwarder_options));
```

## Testing strategy
* LWP's modular design enables unit testing of individual modules, ability to use
dependency injection and mock implementations.
* Unit and functional tests will be written with the intent of trying to reduce or
eliminate dependencies on other components, i.e., ability to test LWP in
Mesos / Marathon environment without LWP Controller and Analytics framework.

## Unsupported Features
The initial version will not have support for the following features:
* HTTPS
* websockets
* CONNECT support
* HTTP2
* scripting / programmability support
* dynamic reconfigurability (except for adding / removing pool members)

## Roadmap
Significant feature enhancements for future iterations of the LWP

### HTTP/2
HTTP/2 functionality will be handled via an existing or future node module (e.g.
node-spdy, spdy, node-http2, etc.). These modules follow NodeJs http and https
APIs which will fit into the design of LWP's middleware. At time of integration
the team will re-evaluate whether the http module can simply be replaced by the
http2 module or if LWP must listen for and handle the upgrade itself; handling
the upgrade manually would only need to be an option if bugs or functional
inconsistencies were discovered.

### WebSockets
WebSockets support will be handled via a stack upgrade. The underlying
node-http-proxy will identify the web sockets upgrade and fire its specialized
callback. The LWP will update the HTTP middleware stack to the TCP middleware
interface thus changing the implementation from a request/response based pattern
to a stream pattern. Specialized middlewares must be built as TCP middlewares in
order to parse and act on the underlying framed protocol marshaled via the web
sockets upgrade.

### UDP
UDP will be handled by a third datagram messaging API. This api will be parallel
to both the HTTP, and TCP APIs, using the same similar signatures, usage
semantics, and continuation callback approach. The basic nature of UDP being
that of connectionless and message based removes the requirement and ability to
track responses (if any). Individual middlewares aware of protocols built on a
UDP base can extend any response characteristics into individual state machines
as any message from either direction will still be visible via these patterns.

UDP's message based semantics will require a new set of LWP wrapper objects to
encapsulate UDP datagrams and allow for transformations.

```javascript
interceptDatagram = function (incomingDatagram, nextDatagramCb)
/*
incomingDataGram = lwpIncomingDatagram
nextDatagramCb = function(err, nextDatagram)
nextDatagram = lwpIncomingDatagram or Buffer
Request chain termination on following:
  1) Non Null Error
  2) Null nextDatagram
  3) nextDatagram is object type Buffer
  4) Exception
UDP is not a connection based request/response protocol. Middleware modules
aware of higher level protocols based on UDP must track their own state native
to that protocol.
*/
```
